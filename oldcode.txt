
function randomTile(){
    //console.log(allTiles)
    let randomIndex = Math.floor(Math.random() * allTiles.length);
    let tile = allTiles[randomIndex][0];
    let color = colors[Math.floor(Math.random() * colors.length)];
    while (players.some(player => player[0][0] === tile || player[1] === color)) {
        randomIndex = Math.floor(Math.random() * allTiles.length);
        tile = allTiles[randomIndex][0];
        color = colors[Math.floor(Math.random() * colors.length)];
    }
    //console.log(`Assigned tile: ${tile} with color: ${color}`);
    return([[tile], color]);
}

function currentPlayerTile(path){
    if (globalPlayer === thisPlayer) {
        for (let i = 0; i < players.length; i++) {
            if (players[i][0].includes(path)) {
                return true; // Tile belongs to the current player
            }
        }
    } else {
        return false;
    }
}

function removeCopies(){
    let clones = document.getElementsByClassName("clone");
    //console.log(clones);
    let viewBox = document.querySelector('g[transform]');
    while (clones.length > 0) {
        let clone = clones[0];
        //console.log(clone);
        viewBox.removeChild(clone);
    }
}

function showAttackOptions(path){
    let n = neighbors[path];
    //console.log(n);
    // putting a green see through copy of the neighboring tile on top of the actual tile
    n.forEach(neighbor => {
        let neighborTile = document.getElementById(neighbor);
        if (neighborTile) {
            let clone = neighborTile.cloneNode(true);
            //console.log(clone);
            clone.setAttribute("fill", "rgba(0, 255, 0, 0.5)");
            clone.setAttribute("stroke", "green");
            clone.setAttribute("stroke-width", "2");
            clone.classList.add("clone");
            clone.setAttribute("pointer-events", "none");
            let viewBox = document.querySelector('g[transform]');
            viewBox.appendChild(clone);
            let neighborsText = document.getElementById(`UI-text-${neighbor}`);
            let neighborCircle = document.getElementById(`UI-text-circle-${neighbor}`);
            console.log(neighborsText);
            // this ensures that the text and circle are on top of the clone
            viewBox.removeChild(neighborsText);
            viewBox.removeChild(neighborCircle);
            //return
            viewBox.appendChild(neighborCircle);
            viewBox.appendChild(neighborsText);
        }
    });
}

function updateTurnCounter(){
    let turnCounter = document.getElementById("turnCounter");
    turnCounter.textContent = `Turn: ${turn}`;
}

function updateText(text, path) {
    let troopCount = 0;
    for (let i = 0; i < allTiles.length; i++) {
        if (allTiles[i][0] === path.id) {
            troopCount = allTiles[i][1];
            break;
        }
    }
    text.textContent = `${path.id}(${troopCount})`;
    text.setAttribute("text-anchor", "middle");
    text.setAttribute("dominant-baseline", "central");
    let fontSize = window.innerWidth / 90
    if (fontSize > 10){
        fontSize = 10
    }
    text.setAttribute("font-size", `${fontSize}px`);
    text.setAttribute("fill", "black");
}

function centerText(text, bbox) {
    text.setAttribute("x", bbox.x + bbox.width / 2);
    text.setAttribute("y", bbox.y + bbox.height / 2);
}

function isBigger(text1, text2) {
    let b1 = document.getElementById(text1.id).getBBox();
    let b2 = document.getElementById(text2.id).getBBox();
    /*if (text2.id === "text-XK" && text1.id === "text-ME") {
        console.log("isBigger called for text-XK and text-ME");
        console.log((b1.width * b1.height) >= (b2.width * b2.height))
    }*/
    return (b1.width * b1.height) >= (b2.width * b2.height);
}

function resizeOverlappingText(text, bbox) {
    let texts = document.querySelectorAll("svg text");
    //console.log(texts);
    let switched = false;
    /*if (text.id === "text-ME") {
        console.log("Resizing text-ME");
        console.log(texts);
    }*/
    texts.forEach(otherText => {
        if (otherText.id !== text.id) {
            let otherBbox = otherText.getBBox();
            /*if (text.id === "text-ME") {
                console.log(otherText.id)
                console.log(bbox)
                console.log(otherBbox)
            }*/
            if (bbox.x < otherBbox.x + otherBbox.width &&
                bbox.x + bbox.width > otherBbox.x &&
                bbox.y < otherBbox.y + otherBbox.height &&
                bbox.y + bbox.height > otherBbox.y) {
                // If the texts overlap, resize the smaller one
                /*if (text.id === "text-ME") {
                    console.log("it is here")
                }*/
                if (isBigger(text, otherText)) {
                    /*if (text.id === "text-ME") {
                        console.log("it is here as well")
                    }
                    if (text.id === "text-ME") {
                        console.log("it is here as well 2")
                    }*/
                    while (bbox.x < otherBbox.x + otherBbox.width &&
                        bbox.x + bbox.width > otherBbox.x &&
                        bbox.y < otherBbox.y + otherBbox.height &&
                        bbox.y + bbox.height > otherBbox.y){
                        let fontSize = parseFloat(text.getAttribute("font-size"));
                        fontSize *= 0.9; // Decrease the font size by 10%
                        text.setAttribute("font-size", `${fontSize}px`);
                        bbox = text.getBBox(); // Update the bounding box after resizing
                        if (fontSize < 5) {
                            if (!switched) {
                                console.warn(`Text ${text.id} is too small to resize further, will resize the other text.`);
                                let t = otherText
                                otherText = text
                                text = t;
                                bbox = text.getBBox(); // Update the bounding box after resizing
                                otherBbox = otherText.getBBox(); // Update the bounding box of the other text
                                switched = true;
                            }else{
                                break
                            }
                        }
                    }
                }
            }
        }
    });
}

function updateTiles() {
    let paths = getTiles();
    paths.forEach(path => {
        for (let i = 0; i < players.length; i++) {
            for (let j = 0; j < players[i][0].length; j++) {
                if (players[i][0][j] === path.id) {
                    //console.log(`Tile ${path.id} is owned by player ${i + 1}`);
                    path.setAttribute("fill", players[i][1]);
                    return; // Exit the loop once the tile is found
                }
            }
        }
    })
}

function countryClick(tileId) {
    //console.log(globalPlayer, thisPlayer);
    highlightTile(tileId);
    //console.log(currentPlayerTile(tileId));
    removeCopies();
    if(currentPlayerTile(tileId)){
        showAttackOptions(tileId)
    }
    //console.log(`Clicked on tile: ${tileId}`);
}
/*
function modifiedSvg(){
    updateTiles();
    let paths = getTiles();
    paths.forEach(path => {
        let bbox = path.getBBox(); // this is the bounding box of the tile, it is used to find the center
        // making a circle under the text
        let circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("cx", bbox.x + bbox.width / 2);
        circle.setAttribute("cy", bbox.y + bbox.height / 2);
        circle.setAttribute("fill", "white");
        circle.setAttribute("stroke", "black");
        circle.setAttribute("stroke-width", "1");
        circle.setAttribute("id", `UI-text-circle-${path.id}`);
        let text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute("pointer-events", "none"); // this is to prevent the text from blocking the clicks on the tiles
        text.setAttribute("id", `UI-text-${path.id}`);
        let viewBox = document.querySelector('g[transform]'); // texts need to be added to the part of the page that pan-zoom library resizes
        viewBox.appendChild(text);
        requestAnimationFrame(() => {
        const bbox = text.getBBox();
        //console.log(bbox);
        circle.setAttribute("r", `${Math.max(text.getBBox().width, text.getBBox().height)/2+1}`); // radius is half of the bigger dimension of the text bounding box plus 5px
        });
        //console.log(document.getElementById("UI-text-" + path.id).getBBox());
        viewBox.removeChild(text) // the text needs to be removed and readded so that its on top of the circle
        viewBox.appendChild(circle);
        viewBox.appendChild(text);
        circle.addEventListener("click", (event) => {
            //console.log(`Clicked on circle of tile: ${path.id}`);
            event.stopPropagation();
            countryClick(path.id);
        });
        circle.addEventListener("mouseover", () => {
            displayFormables(path);
        });
        circle.addEventListener("mouseout", () => {
            resetFormableHighlight();
        });
        updateText(text, path)
        centerText(text, bbox);
    });
    let texts = document.querySelectorAll("svg text");
    texts.forEach(text => {
        if (text.id.startsWith("UI-text-")) {
            let bbox = text.getBBox(); // get the bounding box of the text
            // later change this functions place, this is a temporary solution
            resizeOverlappingText(text, bbox);
        }
    });
}*/

function resetHighligh() {
    let paths = getTiles()
    paths.forEach(path => {
        // removing the highlight and dimmed classes from all tiles
        path.classList.remove("highlighted");
        path.classList.remove("dimmed");
    });
}

function highlightTile(tileId) {
    let paths = getTiles()
    resetHighligh();
    paths.forEach(path => {
        // making the clicked tile lighter and all others darker
        if (path.id === tileId) {
            path.classList.add("highlighted");
        } else{
            path.classList.add("dimmed");
        }
    });
}

function displayFormables(path){
    for (let index = 0; index < allForm.length; index++) {
        for (let i = 0; i< allForm[index].length; i++) {
            if(allForm[index][i] == path.id){
                //console.log(allForm[index][i], path.id)
                let countries = document.querySelectorAll("svg path")
                countries.forEach(country =>{
                    for (let j = 0; j < allForm[index].length; j++) {
                        if (country.id == allForm[index][j]){
                            //console.log("colored a country of a formable")
                            country.setAttribute("stroke-width", "5")
                        }
                    }
                })
                break;
            }
        }
    }
}



function addOtherUI(){
    let s = document.querySelector("svg")
    let pol = document.createElementNS("http://www.w3.org/2000/svg","polygon")
    pol.setAttribute("fill", `black`)
    pol.setAttribute("id", "UI-arrow")
    s.appendChild(pol)
    let pol2 = document.createElementNS("http://www.w3.org/2000/svg","polygon")
    pol2.setAttribute("fill", `black`)
    pol2.setAttribute("id", "UI-arrow2")
    s.appendChild(pol2)
    let rectangle = document.createElementNS("http://www.w3.org/2000/svg","rect")
    rectangle.setAttribute("x", `0`)
    rectangle.setAttribute("y", `${window.innerHeight - window.innerWidth/26 * (playerCount/2)}`)
    rectangle.setAttribute("width", `${window.innerWidth/5}`)
    rectangle.setAttribute("height", `${window.innerWidth/13}`)
    rectangle.setAttribute("fill", "white")
    rectangle.setAttribute("stroke", "black")
    rectangle.setAttribute("stroke-width", "2")
    rectangle.setAttribute("id", "UI-rectangle")
    rectangle.addEventListener("click", () => {
        turn++;
        updateTurnCounter();
        globalPlayer++;
        if (globalPlayer > playerCount) {
            globalPlayer = 1;
        }
        updateArrow(window.innerHeight/2, window.innerWidth/13);
    })
    s.appendChild(rectangle)
    let textN = document.createElementNS("http://www.w3.org/2000/svg","text")
    textN.setAttribute("id", "UI-rectangle-text")
    textN.setAttribute("x", `${window.innerWidth/10}`)
    textN.setAttribute("y", `${window.innerHeight - window.innerWidth/26/1.5}`)
    textN.setAttribute("font-size", `${window.innerWidth/30}px`)
    textN.setAttribute("fill", "black")
    textN.textContent = `Next Turn`;
    textN.setAttribute("text-anchor", "middle");
    textN.setAttribute("pointer-events", "none");
    s.appendChild(textN);
    let textC = document.createElementNS("http://www.w3.org/2000/svg","text")
    textC.setAttribute("id", "turnCounter")
    textC.setAttribute("x", `${window.innerWidth-window.innerWidth/10}`)
    textC.setAttribute("y", `${window.innerHeight/26 *2}`)
    textC.setAttribute("font-size", `${window.innerWidth/30}px`)
    textC.setAttribute("fill", "black")
    textC.textContent = `Turn: ${turn}`;
    textC.setAttribute("text-anchor", "middle");
    s.appendChild(textC);
}

function addUI(i){
    let s = document.querySelector("svg")
    let circle = document.createElementNS("http://www.w3.org/2000/svg","circle")
    // cx="50" cy="50" r="40" stroke="green" stroke-width="2"
    circle.setAttribute("fill", `${players[i][1]}`)
    circle.setAttribute("r", `${window.innerWidth/30}`)
    circle.setAttribute("stroke", `5`)
    circle.setAttribute("stroke-width", `5`)
    circle.setAttribute("id", `UI-playerCircle-${i}`)
    s.appendChild(circle)
    //document.getElementById('mapDiv').innerHTML += s
    //console.log(s.children)
}

function resetFormableHighlight() {
    let countries = document.querySelectorAll("svg path")
        countries.forEach(country =>{
            country.setAttribute("stroke-width", "1")
        })
}

function updateArrow(Ccenter, baseUnit){
    let arrow = document.getElementById("UI-arrow")
    arrow.setAttribute("points", `${baseUnit/2},${Ccenter-baseUnit*(playerCount/2)+baseUnit *globalPlayer-baseUnit*0.8 - baseUnit/2} ${baseUnit/2+baseUnit/4},${Ccenter-baseUnit*(playerCount/2)+baseUnit *globalPlayer -baseUnit*0.8} ${baseUnit/2-baseUnit/4},${Ccenter-baseUnit*(playerCount/2)+baseUnit *globalPlayer-baseUnit*0.8}`)
}

function resizeUI(){
    // resizing the circles
    let circles = document.querySelectorAll("circle")
    //console.log("resizing ui")
    let Ccenter = window.innerHeight/2
    //console.log(Ccenter, playerCount)
    let baseUnit = window.innerWidth/13
    for(let i = 0; i < circles.length; i++){
        circles[i].setAttribute("cx", `${baseUnit/2}`)
        circles[i].setAttribute("cy", `${Ccenter-baseUnit*(playerCount/2)+baseUnit *i}`)
    }
    let arrow2 = document.getElementById("UI-arrow2")
    arrow2.setAttribute("points", `${baseUnit/2+baseUnit},${Ccenter-baseUnit*(playerCount/2)+baseUnit *thisPlayer-baseUnit*0.8 - baseUnit/2} ${baseUnit/2+baseUnit},${Ccenter-baseUnit*(playerCount/2)+baseUnit *thisPlayer -baseUnit*0.8} ${baseUnit/2-baseUnit/2+baseUnit},${Ccenter-baseUnit*(playerCount/2)+baseUnit *thisPlayer-baseUnit*0.8-baseUnit/4}`)
    updateArrow(Ccenter, baseUnit);
}

document.body.addEventListener('click', () => {
  paths.forEach(path => {
    path.classList.remove('highlighted', 'dimmed');
    //removeCopies();
  });
});

for (let i = 0; i < playerCount; i++) {
    players.push(randomTile());
    addUI(i)
}
addOtherUI()
resizeUI()

console.log("Players: ", players);
modifiedSvg();